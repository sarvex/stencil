{
  "components": [
    {
      "filePath": "./src/components/my-component/my-component.tsx",
      "encapsulation": "shadow",
      "tag": "my-component",
      "docs": "",
      "docsTags": [],
      "usage": {},
      "props": [],
      "methods": [
        {
          "name": "onDidDismiss",
          "returns": {
            "type": "Promise<ImportedInterface<T>>",
            "docs": ""
          },
          "complexType": {
            "signature": "<T>(arg: T) => Promise<ImportedInterface<T>>",
            "parameters": [
              {
                "tags": [],
                "text": ""
              }
            ],
            "references": {
              "Promise": {
                "location": "global",
                "id": "../../compiler/lib.es5.d.ts::Promise"
              },
              "ImportedInterface": {
                "location": "import",
                "path": "./imported-interface",
                "id": "src/components/my-component/imported-interface.ts::ImportedInterface"
              },
              "T": {
                "location": "global",
                "id": "src/components/my-component/my-component.tsx::T"
              }
            },
            "return": "Promise<ImportedInterface<T>>"
          },
          "signature": "onDidDismiss<T>(arg: T) => Promise<ImportedInterface<T>>",
          "parameters": [],
          "docs": "Returns a promise that resolves when the toast did dismiss.",
          "docsTags": []
        }
      ],
      "events": [],
      "listeners": [],
      "styles": [],
      "slots": [],
      "parts": [],
      "dependents": [],
      "dependencies": [],
      "dependencyGraph": {}
    }
  ],
  "typeLibrary": {
    "../../compiler/lib.es5.d.ts::Promise": {
      "declaration": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
      "docstring": "Represents the completion of an asynchronous operation",
      "path": "../../compiler/lib.es5.d.ts"
    },
    "src/components/my-component/imported-interface.ts::ImportedInterface": {
      "declaration": "export interface ImportedInterface<T> {\n  test: 'boop';\n  another: T;\n}",
      "docstring": "Some JSDoc here describing something or other\n\nIt's multi-line, etc.",
      "path": "src/components/my-component/imported-interface.ts"
    },
    "src/components/interfaces.ts::Pie": {
      "declaration": "export interface Pie {\n  type: 'pumpkin' | 'apple' | 'pecan';\n  name: string;\n  diameter: number;\n}",
      "docstring": "Interface that should be included",
      "path": "src/components/interfaces.ts"
    },
    "src/components/interfaces.ts::FooBar": {
      "declaration": "{\n  biz: string;\n}",
      "docstring": "",
      "path": "src/components/interfaces.ts"
    },
    "src/components/interfaces.ts::FizzBuzz": {
      "declaration": "export enum FizzBuzz {\n  One,\n  Two,\n  Three,\n}",
      "docstring": "Enum that should be included",
      "path": "src/components/interfaces.ts"
    },
    "src/components/test-not-used.ts::ReExportedUnderNewNameWithType": {
      "declaration": "export interface ReExportedUnderNewNameWithType {\n  test: string;\n}",
      "docstring": "If I show up then a re-export w/ alias and `export type` works!",
      "path": "src/components/test-not-used.ts"
    },
    "src/components/test-not-used.ts::ReExportedUnderNewName": {
      "declaration": "export interface ReExportedUnderNewName {\n  test: string;\n}",
      "docstring": "If I show up then a re-export w/ alias works!",
      "path": "src/components/test-not-used.ts"
    },
    "src/components/test-not-used.ts::ReExportedWithType": {
      "declaration": "export interface ReExportedWithType {\n  test: string;\n}",
      "docstring": "If I show up then a re-export w/ `export type` works!",
      "path": "src/components/test-not-used.ts"
    },
    "src/components/test-not-used.ts::ReExported": {
      "declaration": "export interface ReExported {\n  test: string;\n}",
      "docstring": "If I show up then a re-export works!",
      "path": "src/components/test-not-used.ts"
    },
    "src/components/test-not-used.ts::IncludedInWildcard": {
      "declaration": "export interface IncludedInWildcard {\n  test: string;\n}",
      "docstring": "If I show up then a `export * from '...'` works!",
      "path": "src/components/test-not-used.ts"
    }
  }
}